rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // --- Helpers ---
    function isSignedIn() {
      return request.auth != null;
    }
    function pollDoc(pollId) {
      return get(/databases/$(database)/documents/polls/$(pollId));
    }
    function isOwner(pollId) {
      return isSignedIn() && pollDoc(pollId).data.createdBy == request.auth.uid;
    }
    function isAdmin() {
    	return isSignedIn() && request.auth.token.admin == true;
    }
    // A poll is open if it has no dueAt OR now < dueAt
    function pollOpen(pollId) {
      let p = pollDoc(pollId);
      return !('dueAt' in p.data) || request.time < p.data.dueAt;
    }
    function isPollAdmin(pollId) {
      let p = pollDoc(pollId);
      // Treat owner or global admin as poll admin
      let ownerOrGlobal = isAdmin() || (isSignedIn() && p.data.createdBy == request.auth.uid);
      // If you store admins as an ARRAY of UIDs: ["uid1","uid2",...]
      let arrayListed = ('admins' in p.data) && p.data.admins.hasAny([request.auth.uid]);
      // If you store admins as a MAP of { uid: true }
      let mapListed = ('adminsMap' in p.data) && (request.auth.uid in p.data.adminsMap);
      return ownerOrGlobal || arrayListed || mapListed;
    }


    // --- Polls ---
    match /polls/{pollId} {
      allow read: if true;
      allow create: if isSignedIn();

      // Owner can update, but cannot change dueDate/dueAt once created.
      // (No pollOpen check here so the owner may still edit title/description after the due date if you want.)
      allow update: if isOwner(pollId)
                    && (!('dueDate' in request.resource.data) || request.resource.data.dueDate == resource.data.dueDate)
                    && (!('dueAt'   in request.resource.data) || request.resource.data.dueAt   == resource.data.dueAt);

      match /questions/{questionId} {
        allow read: if true;

        // Questions may only be written while the poll is open (and by the owner).
        allow create, update, delete: if isOwner(pollId) && pollOpen(pollId);
      }
    }

    // --- Submissions (per-user answers & status) ---
    // function noClientLocationFields() {
    //   return !('city' in request.resource.data)
    //       && !('state' in request.resource.data)
    //       && !('zip' in request.resource.data);
    // }
    
//     match /submissions/{docId} {
//       allow read: if true;

//       // Create: must belong to the signer, must specify pollId, and the poll must be open.
//       allow create: if isSignedIn()
//                     && request.resource.data.userId == request.auth.uid
//                     && ('pollId' in request.resource.data)
//                     && pollOpen(request.resource.data.pollId);
//                     // && noClientLocationFields();

//       // Update: signer must own the doc, may not change ownership/identity fields,
//       // and the poll must still be open.
//       allow update: if isSignedIn()
//                     && resource.data.userId == request.auth.uid
//                     // don't allow changing these keys
//                     && (!('userId' in request.resource.data) || request.resource.data.userId == resource.data.userId)
//                     && (!('pollId' in request.resource.data) || request.resource.data.pollId == resource.data.pollId)
//                     && (!('questionId' in request.resource.data) || request.resource.data.questionId == resource.data.questionId)
//                     && pollOpen(resource.data.pollId);
//                     // && noClientLocationFields();
//     }
    match /submissions/{docId} {
      allow read: if isSignedIn() &&
                  (resource.data.userId == request.auth.uid || isPollAdmin(resource.data.pollId));

      allow create: if isSignedIn()
                    && request.resource.data.userId == request.auth.uid
                    && ('pollId' in request.resource.data)
                    && ( !('dueAt' in pollDoc(request.resource.data.pollId).data) || request.time < pollDoc(request.resource.data.pollId).data.dueAt );

      allow update: if isSignedIn()
                    && resource.data.userId == request.auth.uid
                    && (!('userId' in request.resource.data) || request.resource.data.userId == resource.data.userId)
                    && (!('pollId' in request.resource.data) || request.resource.data.pollId == resource.data.pollId)
                    && (!('questionId' in request.resource.data) || request.resource.data.questionId == resource.data.questionId)
                    && ( !('dueAt' in pollDoc(resource.data.pollId).data) || request.time < pollDoc(resource.data.pollId).data.dueAt );
    }
    
    // --- Profiles ---
    match /profiles/{uid} {
      // Owner only
      allow read: if isSignedIn() && request.auth.uid == uid;

      allow create, update: if isSignedIn()
                            && request.auth.uid == uid
                            // Client must NOT set server-managed fields:
                            && !(
                                  ('geo' in request.resource.data)
                                  || ('h3r8' in request.resource.data)
                                  || ('lat' in request.resource.data)
                                  || ('lng' in request.resource.data)
                                );
    }

    
    // path helper
    function ratePath(uid) {
      return /databases/$(database)/documents/feedback_ratelimits/$(uid);
    }

    match /feedback/{id} {
      // Must be signed in AND the batch must also write the rate doc
      // Create only if signed-in AND rate-limit conditions are satisfied.
      allow create: if isSignedIn() && existsAfter(ratePath(request.auth.uid));
      // Reading feedback: keep as you prefer, it's your choice (admin-only, or owner-only, etc.)
      // Example admin-only:
      allow read: if isAdmin();
      allow update, delete: if false;
    }

		// Per-user rate metadata for feedback (not publicly readable)
    match /feedback_ratelimits/{uid} {
      // private
      allow read: if false;

      // Signed-in user can update/create their own rate doc,
      // *but* only if cooldown is satisfied.
      allow create, update: if isSignedIn()
                            && request.auth.uid == uid
                            && (
                                 // first message ever
                                 !exists(ratePath(uid))
                                 // or previous doc lacked lastAt (legacy/cleanup)
                                 || !('lastAt' in get(ratePath(uid)).data)
                                 // otherwise enforce 30s gap
                                 || request.time > get(ratePath(uid)).data.lastAt + duration.value(30, 's')
                               );

      allow delete: if false;
    }
    
    match /contactRequests/{docId} {
      allow create: if request.resource.data.keys().hasAll([
          'fullName','email','subject','createdAt','status','source','subjectKey'
        ])
        && request.resource.data.fullName is string
        && request.resource.data.email is string
        && request.resource.data.subject is string
        && request.resource.data.status == 'new'
        && request.resource.data.source == 'pricing'
        && request.resource.data.subjectKey in ['sales','pilot','general']
        && request.resource.data.createdAt == request.time;
      allow read: if isAdmin();
      allow update, delete: if false; // or your admin condition
    }

	}
}
